package com.jervis.di

import com.jervis.api.SecurityConstants
import com.jervis.service.IAgentOrchestratorService
import com.jervis.service.IClientProjectLinkService
import com.jervis.service.IClientService
import com.jervis.service.IConnectionService
import com.jervis.service.IErrorLogService
import com.jervis.service.IGitConfigurationService
import com.jervis.service.IPendingTaskService
import com.jervis.service.IProjectService
import com.jervis.service.IRagSearchService
import com.jervis.service.ITaskSchedulingService
import com.jervis.service.IUserTaskService
import com.jervis.service.createIAgentOrchestratorService
import com.jervis.service.createIClientProjectLinkService
import com.jervis.service.createIClientService
import com.jervis.service.createIConnectionService
import com.jervis.service.createIErrorLogService
import com.jervis.service.createIGitConfigurationService
import com.jervis.service.createIPendingTaskService
import com.jervis.service.createIProjectService
import com.jervis.service.createIRagSearchService
import com.jervis.service.createITaskSchedulingService
import com.jervis.service.createIUserTaskService
import de.jensklingenberg.ktorfit.Ktorfit
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.call.body
import io.ktor.client.plugins.HttpTimeout
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.plugins.defaultRequest
import io.ktor.client.plugins.logging.DEFAULT
import io.ktor.client.plugins.logging.LogLevel
import io.ktor.client.plugins.logging.Logger
import io.ktor.client.plugins.logging.Logging
import io.ktor.client.request.get
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.client.request.put
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.contentType
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.json.Json

/**
 * Platform-specific HTTP client creation with SSL configuration
 * Each platform implements its own way of handling self-signed certificates
 */
expect fun createPlatformHttpClient(block: HttpClientConfig<*>.() -> Unit): HttpClient

/**
 * Network module for dependency injection
 * Creates Ktorfit client and all service instances
 */
object NetworkModule {
    /**
     * Create HTTP client with common configuration
     * Supports self-signed certificates for all platforms
     */
    fun createHttpClient(): HttpClient =
        createPlatformHttpClient {
            install(ContentNegotiation) {
                json(
                    Json {
                        prettyPrint = true
                        isLenient = true
                        ignoreUnknownKeys = true
                    },
                )
            }

            install(Logging) {
                logger = Logger.DEFAULT
                level = LogLevel.INFO
            }

            install(HttpTimeout) {
                requestTimeoutMillis = 30_000
                connectTimeoutMillis = 10_000
            }

            defaultRequest {
                contentType(ContentType.Application.Json)
                headers[SecurityConstants.CLIENT_HEADER] = SecurityConstants.CLIENT_TOKEN
                headers[SecurityConstants.PLATFORM_HEADER] = SecurityConstants.PLATFORM_DESKTOP
            }
        }

    /**
     * Create Ktorfit instance
     * @param baseUrl Server base URL (e.g., "http://localhost:5500")
     */
    fun createKtorfit(
        baseUrl: String,
        httpClient: HttpClient = createHttpClient(),
    ): Ktorfit =
        Ktorfit
            .Builder()
            .baseUrl(baseUrl)
            .httpClient(httpClient)
            .build()

    /**
     * Create all service instances from Ktorfit
     * These are auto-generated by KSP from interface definitions
     */
    fun createServices(ktorfit: Ktorfit): Services =
        Services(
            projectService = ktorfit.createIProjectService(),
            clientService = ktorfit.createIClientService(),
            clientProjectLinkService = ktorfit.createIClientProjectLinkService(),
            userTaskService = ktorfit.createIUserTaskService(),
            ragSearchService = ktorfit.createIRagSearchService(),
            taskSchedulingService = ktorfit.createITaskSchedulingService(),
            agentOrchestratorService = ktorfit.createIAgentOrchestratorService(),
            errorLogService = ktorfit.createIErrorLogService(),
            gitConfigurationService = ktorfit.createIGitConfigurationService(),
            pendingTaskService = ktorfit.createIPendingTaskService(),
            connectionService = ktorfit.createIConnectionService(),
        )

    /**
     * Container for all services
     */
    data class Services(
        val projectService: IProjectService,
        val clientService: IClientService,
        val clientProjectLinkService: IClientProjectLinkService,
        val userTaskService: IUserTaskService,
        val ragSearchService: IRagSearchService,
        val taskSchedulingService: ITaskSchedulingService,
        val agentOrchestratorService: IAgentOrchestratorService,
        val errorLogService: IErrorLogService,
        val gitConfigurationService: IGitConfigurationService,
        val pendingTaskService: IPendingTaskService,
        val connectionService: IConnectionService,
    )

    // Simple fallback implementation of IUserTaskService using raw HttpClient calls.
    // Intended as a runtime-safe fallback when Ktorfit KSP-generated clients are not
    // available in the classpath (prevents NoClassDefFoundError in the desktop app).
    private class SimpleUserTaskService(
        private val client: HttpClient,
    ) : IUserTaskService {
        override suspend fun listActive(clientId: String): List<com.jervis.dto.user.UserTaskDto> =
            client
                .get("api/user-tasks/active") {
                    parameter("clientId", clientId)
                }.body()

        override suspend fun activeCount(clientId: String): com.jervis.dto.user.UserTaskCountDto =
            client
                .get("api/user-tasks/active-count") {
                    parameter("clientId", clientId)
                }.body()

        override suspend fun cancel(taskId: String): com.jervis.dto.user.UserTaskDto =
            client
                .put("api/user-tasks/cancel") {
                    parameter("taskId", taskId)
                }.body()

        override suspend fun sendToAgent(
            taskId: String,
            routingMode: com.jervis.dto.user.TaskRoutingMode,
            additionalInput: String?,
        ): com.jervis.dto.user.UserTaskDto =
            client
                .post("api/user-tasks/send-to-agent") {
                    parameter("taskId", taskId)
                    parameter("routingMode", routingMode)
                    setBody(additionalInput ?: "")
                }.body()
    }
}

/**
 * Extension to easily create all services
 */
fun createJervisServices(baseUrl: String): NetworkModule.Services {
    val httpClient = NetworkModule.createHttpClient()
    val ktorfit = NetworkModule.createKtorfit(baseUrl, httpClient)
    return NetworkModule.createServices(ktorfit)
}

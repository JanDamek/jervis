package com.jervis.koog.qualifier

import ai.koog.agents.core.agent.AIAgent
import ai.koog.agents.core.agent.config.AIAgentConfig
import ai.koog.agents.core.dsl.builder.forwardTo
import ai.koog.agents.core.dsl.builder.strategy
import ai.koog.agents.core.dsl.extension.nodeExecuteTool
import ai.koog.agents.core.dsl.extension.nodeLLMRequest
import ai.koog.agents.core.dsl.extension.nodeLLMRequestStructured
import ai.koog.agents.core.dsl.extension.nodeLLMSendToolResult
import ai.koog.agents.core.dsl.extension.onAssistantMessage
import ai.koog.agents.core.dsl.extension.onToolCall
import ai.koog.agents.core.feature.handler.agent.AgentCompletedContext
import ai.koog.agents.core.feature.handler.agent.AgentStartingContext
import ai.koog.agents.core.tools.ToolRegistry
import ai.koog.agents.core.tools.reflect.tools
import ai.koog.agents.features.eventHandler.feature.EventHandler
import ai.koog.prompt.dsl.Prompt
import ai.koog.prompt.structure.StructuredResponse
import com.jervis.configuration.properties.KoogProperties
import com.jervis.dto.PendingTaskStateEnum
import com.jervis.entity.PendingTaskDocument
import com.jervis.entity.shouldProcessWithVision
import com.jervis.graphdb.GraphDBService
import com.jervis.koog.KoogPromptExecutorFactory
import com.jervis.koog.OllamaProviderSelector
import com.jervis.koog.SmartModelSelector
import com.jervis.koog.qualifier.types.ChunkContext
import com.jervis.koog.qualifier.types.Phase1Context
import com.jervis.koog.qualifier.types.Phase1JsonOutput
import com.jervis.koog.qualifier.types.VisionContext
import com.jervis.koog.tools.GraphRagTools
import com.jervis.koog.tools.TaskTools
import com.jervis.rag.KnowledgeService
import com.jervis.service.background.PendingTaskService
import com.jervis.service.link.IndexedLinkService
import com.jervis.service.link.LinkContentService
import com.jervis.service.scheduling.TaskManagementService
import com.jervis.service.task.UserTaskService
import com.jervis.service.token.TokenCountingService
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import mu.KotlinLogging
import org.springframework.stereotype.Service

@Service
class KoogQualifierAgent(
    private val promptExecutorFactory: KoogPromptExecutorFactory,
    private val graphService: GraphDBService,
    private val knowledgeService: KnowledgeService,
    private val koogProperties: KoogProperties,
    private val pendingTaskService: PendingTaskService,
    private val ollamaProviderSelector: OllamaProviderSelector,
    private val taskManagementService: TaskManagementService,
    private val userTaskService: UserTaskService,
    private val linkContentService: LinkContentService,
    private val indexedLinkService: IndexedLinkService,
    private val smartModelSelector: SmartModelSelector,
    private val tokenCountingService: TokenCountingService,
    private val directoryStructureService: com.jervis.service.storage.DirectoryStructureService,
) {
    private val logger = KotlinLogging.logger {}
    private val supervisor = SupervisorJob()
    private val scope = CoroutineScope(Dispatchers.IO + supervisor)

    // Data classes for type-safe data flow
    data class Phase1Result(
        val chunks: List<String>,
        val baseNodeKey: String? = null, // Base document node key (e.g., "doc_literature_screening")
        val baseInfo: String? = null, // High-level document description for base node
        val earlyRouting: String? = null, // "DONE" or "LIFT_UP" if agent decided to skip processing
    )

    data class ProcessingState(
        val chunks: List<String>,
        val baseNodeKey: String, // Base document node to link chunks to
        val baseInfo: String?, // Not used anymore (baseInfo already prepended to chunks)
        val processedCount: Int,
        val currentIndex: Int,
    ) {
        fun hasMoreChunks(): Boolean = currentIndex < chunks.size

        fun nextChunk(): String? = chunks.getOrNull(currentIndex)

        fun nextState(): ProcessingState =
            copy(
                processedCount = processedCount + 1,
                currentIndex = currentIndex + 1,
            )
    }

    fun create(task: PendingTaskDocument): AIAgent<String, String> {
        val agentStrategy =
            strategy<String, String>("Jervis Qualifier Strategy") {
                // Node: Vision augmentation - returns VisionContext (original text + vision annex)
                val nodeVisionAugment by node<String, VisionContext>("üîç Vision Augment") { _ ->
                    val visualAttachments = task.attachments.filter { it.shouldProcessWithVision() }
                    logger.info {
                        "üîç VISION_CHECK | correlationId=${task.correlationId} | " +
                            "totalAttachments=${task.attachments.size} | visualAttachments=${visualAttachments.size}"
                    }

                    if (visualAttachments.isEmpty()) {
                        logger.info { "üîç VISION_SKIP | correlationId=${task.correlationId} | reason=no_visual_attachments" }
                        return@node VisionContext(
                            originalText = task.content,
                            visionAnnex = null,
                            attachments = task.attachments,
                        )
                    }

                    // Select vision model
                    val visionModel =
                        smartModelSelector.selectVisionModel(
                            baseModelName = "qwen3-vl:latest",
                            textPrompt = "Analyze images and extract ALL visible information. Return JSON.",
                            images =
                                visualAttachments.map {
                                    SmartModelSelector.ImageMetadata(
                                        widthPixels = 1920,
                                        heightPixels = 1080,
                                        format = it.mimeType,
                                    )
                                },
                            outputReserve = 2000,
                        )

                    logger.info {
                        "üîç VISION_MODEL | correlationId=${task.correlationId} | " +
                            "model=${visionModel.id} | attachments=${visualAttachments.size}"
                    }

                    // Execute vision analysis
                    val result =
                        runVisionWithKoog(
                            executor = promptExecutorFactory.getExecutor(ollamaProviderSelector.getProvider()),
                            model = visionModel,
                            originalText = task.content,
                            attachments = task.attachments,
                            directoryStructureService = directoryStructureService,
                        )

                    logger.info {
                        "üîç VISION_SUCCESS | correlationId=${task.correlationId} | " +
                            "hasVisionAnnex=${result.visionAnnex != null} | " +
                            "processedAttachments=${result.attachments.count { it.visionAnalysis != null }}"
                    }

                    result
                }

                // =================================================================
                // PHASE 1: QUALIFY & SPLIT with LLM structured output
                // =================================================================
                val phase1Subgraph by subgraph<String, Phase1Result>(name = "üìã Phase 1: Qualify & Split") {
                    // Subgraph-scoped state (acceptable pattern for retry tracking)
                    var currentRetryAttempt = 0
                    val maxRetries = 2
                    var savedOriginalDocument = ""

                    // Node: Capture input for offset extraction
                    val nodeCaptureInput by node<String, String>("Capture Input Document") { input ->
                        savedOriginalDocument = input
                        input
                    }

                    // Use structured output with offset-based examples (prevents JSON escaping issues)
                    val nodeSendPh1Request by nodeLLMRequestStructured<Phase1JsonOutput>(
                        name = "Send Phase 1 Structured Request",
                        examples =
                            listOf(
                                Phase1JsonOutput(
                                    earlyRouting = null,
                                    baseInfo = "Email from Alza.cz regarding order delay for case ASRE241171814.",
                                    blocks =
                                        listOf(
                                            BlockPlan("B1", "Header and greeting", 0, 200),
                                            BlockPlan("B2", "Main issue description", 200, 1200),
                                            BlockPlan("B3", "Delay reason and timeline", 1200, 2500),
                                        ),
                                ),
                                Phase1JsonOutput(
                                    earlyRouting = "DONE",
                                    baseInfo = "Empty spam email",
                                    blocks = emptyList(),
                                ),
                            ),
                    )

                    // Data class to handle both success and retry cases
                    data class Ph1ParseResult(
                        val success: Boolean,
                        val result: Phase1Result?,
                        val errorMessage: String? = null,
                        val retryAttempt: Int = 0,
                    )

                    // Build state from structured response with guardrails (Koog pattern)
                    val nodeBuildState by node<Result<StructuredResponse<Phase1JsonOutput>>, Ph1ParseResult>(
                        "Build State from Structured Response",
                    ) { result ->
                        if (result.isFailure) {
                            val error = result.exceptionOrNull()
                            logger.error(error) { "üìã PHASE_1_STRUCTURED_FAIL | message=${error?.message}" }

                            return@node Ph1ParseResult(
                                success = false,
                                result = null,
                                errorMessage = error?.message ?: "Structured output failed",
                                retryAttempt = currentRetryAttempt,
                            )
                        }

                        val structured = result.getOrThrow().structure

                        logger.info {
                            "üìã PHASE_1_STRUCTURED_SUCCESS | correlationId=${task.correlationId} | " +
                                "blocksCount=${structured.blocks.size} | baseInfo='${structured.baseInfo.take(100)}'"
                        }

                        // Guardrails: validate structured output
                        if (structured.blocks.isEmpty() && structured.earlyRouting == null) {
                            logger.warn { "üìã PHASE_1_VALIDATION_FAIL | empty blocks and no earlyRouting" }
                            return@node Ph1ParseResult(
                                success = false,
                                result = null,
                                errorMessage = "Empty blocks and no earlyRouting",
                                retryAttempt = currentRetryAttempt,
                            )
                        }

                        if (structured.baseInfo.isBlank() && structured.earlyRouting == null) {
                            logger.warn { "üìã PHASE_1_VALIDATION_FAIL | missing baseInfo" }
                            return@node Ph1ParseResult(
                                success = false,
                                result = null,
                                errorMessage = "Missing baseInfo",
                                retryAttempt = currentRetryAttempt,
                            )
                        }

                        // Guardrails: filter and validate block offsets
                        val originalInput = savedOriginalDocument
                        val safeBlockPlans =
                            structured.blocks
                                .asSequence()
                                .filter { it.startChar >= 0 && it.endChar <= originalInput.length }
                                .filter { it.endChar > it.startChar } // Valid range
                                .take(50) // Max blocks guard
                                .toList()

                        // Extract chunks from offsets
                        val chunks =
                            safeBlockPlans.map { block ->
                                originalInput.substring(block.startChar, block.endChar)
                            }

                        // Fallback: if no valid blocks, use entire document
                        val finalChunks =
                            if (chunks.isEmpty()) {
                                logger.warn { "üìã PHASE_1_FALLBACK | No valid blocks, using entire document as single chunk" }
                                listOf(originalInput)
                            } else {
                                chunks
                            }

                        logger.debug {
                            "üìã PHASE_1_GUARDRAILS | blockPlans=${structured.blocks.size} | safe=${safeBlockPlans.size} | chunks=${finalChunks.size}"
                        }

                        currentRetryAttempt = 0
                        val baseNodeKey = "doc_${task.correlationId.replace("-", "_")}"

                        Ph1ParseResult(
                            success = true,
                            result =
                                Phase1Result(
                                    chunks = finalChunks,
                                    baseNodeKey = baseNodeKey,
                                    baseInfo = structured.baseInfo,
                                    earlyRouting = structured.earlyRouting,
                                ),
                        )
                    }

                    val nodeUnwrapSuccess by node<Ph1ParseResult, Phase1Result>("Unwrap Phase 1 Success") { parseResult ->
                        parseResult.result!!
                    }

                    data class RetryDecision(
                        val shouldRetry: Boolean,
                        val prompt: String?,
                        val nextRetryAttempt: Int,
                    )

                    val nodeRetryOrFail by node<Ph1ParseResult, RetryDecision>("Phase 1 Retry Decision") { parseResult ->
                        val currentAttempt = parseResult.retryAttempt
                        val nextAttempt = currentAttempt + 1

                        logger.warn {
                            "Phase 1: Invalid response (attempt $nextAttempt/$maxRetries). Model did not output valid JSON."
                        }

                        if (nextAttempt > maxRetries) {
                            logger.error { "Phase 1: Max retries ($maxRetries) exceeded, will mark as ERROR" }
                            return@node RetryDecision(
                                shouldRetry = false,
                                prompt = null,
                                nextRetryAttempt = nextAttempt,
                            )
                        }

                        // Strong retry prompt emphasizing offset-based blocks
                        val retryPrompt =
                            """
üö® ERROR: You did NOT output valid JSON.

**WHAT YOU MUST OUTPUT:**

ONLY valid JSON in this exact format (no markdown, no explanation):

{
  "earlyRouting": null,
  "baseInfo": "One sentence summary of the document",
  "blocks": [
    {"id": "B1", "label": "Brief description", "startChar": 0, "endChar": 500},
    {"id": "B2", "label": "Brief description", "startChar": 500, "endChar": 1200}
  ]
}

**CRITICAL:**
- blocks are CHARACTER OFFSETS (startChar/endChar), NOT raw text
- startChar is 0-based position in document (inclusive)
- endChar is end position (exclusive)
- Each block: 500-3000 tokens (estimate: 1 token ‚âà 4 chars)

**NEGATIVE CONSTRAINTS:**
‚ùå Do NOT embed raw text in blocks array
‚ùå Do NOT use placeholders like "block 1 text"
‚ùå Do NOT explain or add text outside JSON
‚ùå Do NOT use markdown code fences

Document length: ${savedOriginalDocument.length} characters

**FINAL INSTRUCTION:**
Output ONLY the JSON object with blocks as offset references.

START NOW:
                            """.trimIndent()

                        RetryDecision(shouldRetry = true, prompt = retryPrompt, nextRetryAttempt = nextAttempt)
                    }

                    val nodeHandleRetryFailed by node<RetryDecision, Phase1Result>("Handle Phase 1 Retry Failed") {
                        logger.error {
                            "üìã PHASE_1_RETRY_FAILED | correlationId=${task.correlationId} | maxRetries=$maxRetries | result=ERROR"
                        }
                        Phase1Result(
                            chunks = emptyList(),
                            baseNodeKey = null,
                            baseInfo = null,
                            earlyRouting = "ERROR",
                        )
                    }

                    // Node to prepare retry: update attempt counter and return prompt
                    val nodeCreateRetryPrompt by node<RetryDecision, String>("Create Phase 1 Retry Prompt") { decision ->
                        currentRetryAttempt = decision.nextRetryAttempt
                        logger.info {
                            "üìã PHASE_1_RETRY | correlationId=${task.correlationId} | attempt=$currentRetryAttempt/$maxRetries"
                        }
                        decision.prompt!!
                    }

                    edge(nodeStart forwardTo nodeCaptureInput)
                    edge(nodeCaptureInput forwardTo nodeSendPh1Request)
                    // nodeLLMRequestStructured returns Result<StructuredResponse<T>>
                    edge(nodeSendPh1Request forwardTo nodeBuildState)

                    // Build state routing: success or retry
                    edge(
                        (nodeBuildState forwardTo nodeUnwrapSuccess).onCondition { parseResult ->
                            parseResult.success
                        },
                    )
                    edge(
                        (nodeBuildState forwardTo nodeRetryOrFail).onCondition { parseResult ->
                            !parseResult.success
                        },
                    )

                    // Retry decision routing
                    edge(
                        (nodeRetryOrFail forwardTo nodeHandleRetryFailed).onCondition { decision ->
                            !decision.shouldRetry
                        },
                    )
                    edge(
                        (nodeRetryOrFail forwardTo nodeCreateRetryPrompt).onCondition { decision ->
                            decision.shouldRetry
                        },
                    )

                    // Retry with structured output (same examples)
                    val nodeSendRetry by nodeLLMRequestStructured<Phase1JsonOutput>(
                        name = "Send Phase 1 Retry Request",
                        examples =
                            listOf(
                                Phase1JsonOutput(
                                    earlyRouting = null,
                                    baseInfo = "Email from Alza.cz regarding order delay for case ASRE241171814.",
                                    blocks =
                                        listOf(
                                            BlockPlan("B1", "Header and greeting", 0, 200),
                                            BlockPlan("B2", "Delay explanation", 200, 500),
                                        ),
                                ),
                            ),
                    )
                    edge(nodeCreateRetryPrompt forwardTo nodeSendRetry)
                    // Retry goes back to build state
                    edge(nodeSendRetry forwardTo nodeBuildState)

                    // Success paths
                    edge(nodeUnwrapSuccess forwardTo nodeFinish)
                    edge(nodeHandleRetryFailed forwardTo nodeFinish)
                }

                // =================================================================
                // PHASE 2: MAP - Process each chunk
                // =================================================================
                // First create base document node
                val nodeCreateBaseDoc by node<Phase1Result, Phase1Result>("Create Base Document Node") { phase1 ->
                    if (phase1.baseInfo != null && phase1.baseNodeKey != null) {
                        logger.info {
                            "üìÑ BASE_NODE_CREATE_START | correlationId=${task.correlationId} | nodeKey=${phase1.baseNodeKey}"
                        }
                        try {
                            // Direct suspend call - no runBlocking needed (node is already suspend)
                            val storeRequest =
                                com.jervis.rag.StoreChunkRequest(
                                    clientId = task.clientId,
                                    projectId = task.projectId,
                                    content = phase1.baseInfo,
                                    graphRefs = listOf(phase1.baseNodeKey),
                                    sourceUrn = task.sourceUrn,
                                )
                            val chunkId = knowledgeService.storeChunk(storeRequest)

                            // Create graph node
                            graphService.upsertNode(
                                clientId = task.clientId,
                                node =
                                    com.jervis.graphdb.model.GraphNode(
                                        key = phase1.baseNodeKey.replace("::", "_"),
                                        entityType = "document",
                                        ragChunks = listOf(chunkId),
                                    ),
                            )
                            logger.info {
                                "üìÑ BASE_NODE_CREATED | correlationId=${task.correlationId} | " +
                                    "nodeKey=${phase1.baseNodeKey} | chunkId=$chunkId"
                            }
                        } catch (e: Exception) {
                            logger.error(e) { "Failed to create base document node" }
                        }
                    }
                    phase1
                }

                val nodeInitProcessing by node<Phase1Result, ProcessingState>("Initialize Chunk Processing") { phase1 ->
                    logger.info {
                        "üîÑ PHASE_2_START | correlationId=${task.correlationId} | totalChunks=${phase1.chunks.size}"
                    }
                    // Prepend baseInfo to each chunk
                    val chunksWithBase =
                        if (phase1.baseInfo != null) {
                            phase1.chunks.map { chunk ->
                                """${phase1.baseInfo}

---

$chunk"""
                            }
                        } else {
                            phase1.chunks
                        }

                    ProcessingState(
                        chunks = chunksWithBase,
                        baseNodeKey = phase1.baseNodeKey ?: "doc_unknown",
                        baseInfo = null, // No longer needed, already prepended
                        processedCount = 0,
                        currentIndex = 0,
                    )
                }

                val processingSubgraph by subgraph<ProcessingState, ProcessingState>(name = "üîÑ Phase 2: Chunk Processing") {
                    // Local subgraph state (acceptable pattern for subgraph-scoped tracking)
                    var currentProcessingState: ProcessingState? = null

                    val nodeStoreState by node<ProcessingState, ProcessingState>("Store Processing State") { state ->
                        currentProcessingState = state
                        state
                    }

                    val nodePrepareChunk by node<ProcessingState, String>("Prepare Chunk for Processing") { state ->
                        val chunk = state.nextChunk()
                        val chunkIndex = state.currentIndex + 1

                        logger.info {
                            "üîÑ CHUNK_PROCESSING | correlationId=${task.correlationId} | " +
                                "chunkIndex=$chunkIndex/${state.chunks.size} | chunkLength=${chunk?.length ?: 0}"
                        }

                        """
${PROMPT_PHASE_2}

**BASE_NODE_KEY: ${state.baseNodeKey}**

**CHUNK $chunkIndex of ${state.chunks.size}:**
$chunk
                        """.trimIndent()
                    }

                    val nodeSendChunk by nodeLLMRequest(name = "Send Chunk LLM Request")
                    val nodeExecuteStore by nodeExecuteTool(name = "Execute Store Tool")
                    val nodeSendStoreResult by nodeLLMSendToolResult(name = "Send Store Tool Result")

                    // Track retry attempts per chunk
                    var chunkRetryCount = 0
                    val maxChunkRetries = 1

                    data class RetryDecisionPhase2(
                        val shouldRetry: Boolean,
                        val retryPrompt: String,
                    )

                    // Handle invalid response - retry with strong prompt
                    val nodeChunkRetryOrSkip by node<String, RetryDecisionPhase2>("Chunk Retry Decision") { assistantMessage ->
                        chunkRetryCount++
                        logger.warn {
                            "üîÑ CHUNK_RETRY | correlationId=${task.correlationId} | " +
                                "attempt=$chunkRetryCount/$maxChunkRetries | " +
                                "response='${assistantMessage.take(100)}'"
                        }

                        val shouldRetry = chunkRetryCount <= maxChunkRetries
                        if (!shouldRetry) {
                            logger.error { "Phase 2: Max retries exceeded, skipping chunk" }
                        }

                        // Strong retry prompt
                        val retryPrompt =
                            """
üö® ERROR: You replied with text instead of calling the storeKnowledge tool.

**WHAT YOU DID WRONG:**
You wrote "${assistantMessage.take(100)}" instead of calling the tool.

**WHAT YOU MUST DO NOW:**
Call the `storeKnowledge` tool with these parameters:
- content: Semantic description of what this chunk is about
- graphStructure: List of relationships (MUST include "-[PART_OF]-> ${currentProcessingState?.baseNodeKey}")
- mainNodeKey: Primary concept identifier

üö® **DO NOT REPLY WITH TEXT. CALL THE TOOL.**

**CHUNK TO PROCESS:**
${currentProcessingState?.nextChunk() ?: ""}
                            """.trimIndent()

                        RetryDecisionPhase2(shouldRetry = shouldRetry, retryPrompt = retryPrompt)
                    }

                    val nodeSkipChunk by node<RetryDecisionPhase2, String>("Skip Chunk After Retry Failure") { _ ->
                        logger.warn {
                            "üîÑ CHUNK_SKIPPED | correlationId=${task.correlationId} | reason='max retries exceeded'"
                        }
                        "Skipped - no valid response: ChunkId: skipped, MainNode: skipped"
                    }

                    val nodeCreateRetryPromptPhase2 by node<RetryDecisionPhase2, String>("Create Chunk Retry Prompt") { decision ->
                        decision.retryPrompt
                    }

                    val nodeSendChunkRetry by nodeLLMRequest(name = "Send Chunk Retry Request")

                    val nodeRecordResult by node<String, ProcessingState>("Record Chunk Result") { assistantMessage ->
                        // Reset retry counter for next chunk
                        chunkRetryCount = 0

                        val state = currentProcessingState ?: throw IllegalStateException("No current processing state")
                        logger.info {
                            "üîÑ CHUNK_COMPLETE | correlationId=${task.correlationId} | " +
                                "chunkIndex=${state.currentIndex + 1}/${state.chunks.size} | " +
                                "assistantResponse='${assistantMessage.take(100)}'"
                        }

                        // Update state - move to next chunk
                        state.nextState()
                    }

                    // Start: store state and check if has more chunks
                    edge(nodeStart forwardTo nodeStoreState)
                    edge((nodeStoreState forwardTo nodePrepareChunk).onCondition { state -> state.hasMoreChunks() })
                    edge((nodeStoreState forwardTo nodeFinish).onCondition { state -> !state.hasMoreChunks() })

                    // Processing flow
                    edge(nodePrepareChunk forwardTo nodeSendChunk)
                    edge((nodeSendChunk forwardTo nodeExecuteStore).onToolCall { true })
                    // If LLM didn't call tool (contract violation), retry
                    edge((nodeSendChunk forwardTo nodeChunkRetryOrSkip).onAssistantMessage { true })
                    edge(nodeExecuteStore forwardTo nodeSendStoreResult)

                    // Handle multiple tool calls: if LLM returns more tool calls, execute them
                    edge((nodeSendStoreResult forwardTo nodeExecuteStore).onToolCall { true })
                    // Only proceed to record result when LLM returns assistant message (confirmation)
                    edge((nodeSendStoreResult forwardTo nodeRecordResult).onAssistantMessage { true })

                    // Retry flow
                    edge((nodeChunkRetryOrSkip forwardTo nodeCreateRetryPromptPhase2).onCondition { decision -> decision.shouldRetry })
                    edge((nodeChunkRetryOrSkip forwardTo nodeSkipChunk).onCondition { decision -> !decision.shouldRetry })
                    edge(nodeCreateRetryPromptPhase2 forwardTo nodeSendChunkRetry)
                    edge((nodeSendChunkRetry forwardTo nodeExecuteStore).onToolCall { true })
                    // If retry also fails (no tool call), create decision again
                    edge((nodeSendChunkRetry forwardTo nodeChunkRetryOrSkip).onAssistantMessage { true })
                    edge(nodeSkipChunk forwardTo nodeRecordResult)

                    // Loop back or finish
                    edge((nodeRecordResult forwardTo nodeStoreState).onCondition { state -> state.hasMoreChunks() })
                    edge((nodeRecordResult forwardTo nodeFinish).onCondition { state -> !state.hasMoreChunks() })
                }

                // =================================================================
                // PHASE 3: FINAL ROUTING (previously Phase 4)
                // =================================================================
                val nodePrepareRouting by node<ProcessingState, String>("Prepare Final Routing") { state ->
                    logger.info {
                        "üéØ PHASE_3_START | correlationId=${task.correlationId} | " +
                            "baseNode=${state.baseNodeKey} | processedChunks=${state.processedCount}"
                    }
                    """
${PROMPT_PHASE_3}

**SUMMARY:**
- Base document node created: ${state.baseNodeKey}
- Processed ${state.processedCount} chunks
- All chunks linked to base node via -[PART_OF]-> edges
- All chunks indexed to RAG + Graph
- Any tasks/links/actions have been delegated

Decide: DONE or LIFT_UP?
                    """.trimIndent()
                }

                val routingSubgraph by subgraph<String, String>(name = "üéØ Phase 3: Final Routing") {
                    val nodeSendRoutingRequest by nodeLLMRequest(name = "Send Routing LLM Request")
                    val nodeExecuteRouting by nodeExecuteTool(name = "Execute Routing Tool")
                    val nodeSendRoutingResult by nodeLLMSendToolResult(name = "Send Routing Tool Result")

                    // Retry logic if LLM doesn't call routeTask tool
                    val nodeRoutingRetry by node<String, String>("Routing Retry") { assistantMessage ->
                        logger.warn {
                            "üéØ ROUTING_RETRY | correlationId=${task.correlationId} | " +
                                "LLM didn't call routeTask tool, got text: ${assistantMessage.take(100)}"
                        }
                        """
üö® ERROR: You must call the `routeTask` tool, not reply with text.

**WHAT YOU DID WRONG:**
You wrote "${assistantMessage.take(100)}" instead of calling the tool.

**WHAT YOU MUST DO NOW:**
Call `routeTask("DONE")` or `routeTask("LIFT_UP")` immediately.

üö® **DO NOT REPLY WITH TEXT. CALL THE TOOL.**
                        """.trimIndent()
                    }

                    val nodeSendRoutingRetry by nodeLLMRequest(name = "Send Routing Retry Request")

                    edge(nodeStart forwardTo nodeSendRoutingRequest)
                    edge((nodeSendRoutingRequest forwardTo nodeExecuteRouting).onToolCall { true })
                    // If LLM didn't call tool (contract violation), retry once
                    edge((nodeSendRoutingRequest forwardTo nodeRoutingRetry).onAssistantMessage { true })
                    edge(nodeRoutingRetry forwardTo nodeSendRoutingRetry)
                    edge((nodeSendRoutingRetry forwardTo nodeExecuteRouting).onToolCall { true })
                    // If retry also fails, finish anyway (graceful degradation)
                    edge((nodeSendRoutingRetry forwardTo nodeFinish).onAssistantMessage { true })

                    edge(nodeExecuteRouting forwardTo nodeSendRoutingResult)
                    // Handle multiple tool calls (unlikely but consistent pattern)
                    edge((nodeSendRoutingResult forwardTo nodeExecuteRouting).onToolCall { true })
                    edge((nodeSendRoutingResult forwardTo nodeFinish).onAssistantMessage { true })
                }

                // Helper node to convert Phase1Result to String for early exit
                val nodeEarlyExit by node<Phase1Result, String>("Handle Early Exit") { result ->
                    logger.info {
                        "üéØ EARLY_EXIT | correlationId=${task.correlationId} | routing=${result.earlyRouting}"
                    }
                    "Phase 1 completed with routing: ${result.earlyRouting ?: "UNKNOWN"}"
                }

                // =================================================================
                // MAIN FLOW
                // =================================================================
                // Vision (Phase 0) ‚Üí Phase 1 ‚Üí Check result
                edge(nodeStart forwardTo nodeVisionAugment)
                edge(nodeVisionAugment forwardTo nodeExtractAugmentedText)
                edge(nodeExtractAugmentedText forwardTo phase1Subgraph)

                // If Phase 1 returned early routing (DONE/LIFT_UP), finish immediately
                edge((phase1Subgraph forwardTo nodeEarlyExit).onCondition { result -> result.earlyRouting != null })
                edge(nodeEarlyExit forwardTo nodeFinish)

                // If Phase 1 returned empty chunks, finish (shouldn't happen, but safe)
                edge((phase1Subgraph forwardTo nodeEarlyExit).onCondition { result -> result.chunks.isEmpty() })

                // Normal flow: Phase 1 ‚Üí Create base ‚Üí Phase 2 ‚Üí Phase 3 (Routing)
                edge(
                    (phase1Subgraph forwardTo nodeCreateBaseDoc).onCondition { result ->
                        result.earlyRouting == null && result.chunks.isNotEmpty()
                    },
                )
                edge(nodeCreateBaseDoc forwardTo nodeInitProcessing)
                edge(nodeInitProcessing forwardTo processingSubgraph)
                edge(processingSubgraph forwardTo nodePrepareRouting)
                edge(nodePrepareRouting forwardTo routingSubgraph)
                edge(routingSubgraph forwardTo nodeFinish)
            }

        // Dynamic model selection based on task content length
        // SmartModelSelector uses exact BPE token counting (jtokkit)
        // Output reserve: Phase 1 generates chunks (similar size to input) + metadata
        // Formula: output ‚âà 1.5x input (chunks are ~same size, plus baseInfo and delimiters)
        val inputTokens = tokenCountingService.countTokens(task.content)
        val dynamicOutputReserve = (inputTokens * 1.5).toInt().coerceAtLeast(2000)

        val dynamicModel =
            smartModelSelector.selectModel(
                baseModelName = MODEL_QUALIFIER_NAME, // Base: qwen3-coder-tool:30b
                inputContent = task.content,
                outputReserve = dynamicOutputReserve, // Dynamic: 1.5x input tokens
            )

        logger.info {
            "KoogQualifierAgent | Dynamic model selected: ${dynamicModel.id} | " +
                "contextLength=${dynamicModel.contextLength} | " +
                "taskContentLength=${task.content.length} | " +
                "inputTokens=$inputTokens | " +
                "outputReserve=$dynamicOutputReserve | " +
                "baseModel=$MODEL_QUALIFIER_NAME"
        }

        val agentConfig =
            AIAgentConfig(
                prompt =
                    Prompt.build("jervis-qualifier-main") {
                        system("You are JERVIS Qualification Agent. Follow phase-specific instructions provided in user messages.")
                    },
                model = dynamicModel, // Dynamic model from SmartModelSelector
                maxAgentIterations = koogProperties.maxIterations,
            )

        val toolRegistry =
            ToolRegistry {
                tools(GraphRagTools(graphService, knowledgeService, task))
                tools(
                    TaskTools(
                        task = task,
                        taskManagementService = taskManagementService,
                        userTaskService = userTaskService,
                        pendingTaskService = pendingTaskService,
                        linkContentService = linkContentService,
                        indexedLinkService = indexedLinkService,
                        coroutineScope = scope,
                    ),
                )
            }

        return AIAgent(
            promptExecutor = promptExecutorFactory.getExecutor(ollamaProviderSelector.getProvider()),
            toolRegistry = toolRegistry,
            strategy = agentStrategy,
            agentConfig = agentConfig,
            installFeatures = {
                install(feature = EventHandler) {
                    onAgentStarting { eventContext: AgentStartingContext ->
                        logger.info { "Starting agent: ${eventContext.agent.id}" }
                    }
                    onAgentCompleted { eventContext: AgentCompletedContext ->
                        logger.info { "Result: ${eventContext.result}" }
                    }
                }
            },
        )
    }

    suspend fun run(task: PendingTaskDocument): QualifierResult {
        val startTime = System.currentTimeMillis()
        logger.info { "üîµ KOOG_QUALIFIER_START (Map-Reduce Strategy) | correlationId=${task.correlationId}" }
        try {
            val agent = create(task)
            agent.run(task.content)
            val duration = System.currentTimeMillis() - startTime
            logger.info { "üü¢ KOOG_QUALIFIER_COMPLETE | correlationId=${task.correlationId} | duration=${duration}ms" }
            return QualifierResult(completed = true)
        } catch (e: Exception) {
            val duration = System.currentTimeMillis() - startTime
            logger.error(
                e,
            ) { "‚ùå KOOG_QUALIFIER_FAILED | correlationId=${task.correlationId} | duration=${duration}ms | error=${e.message}" }

            // Check if this is a timeout or transient error that should be retried
            val isRetryableError = isRetryableError(e)

            if (isRetryableError) {
                // Return task to READY_FOR_QUALIFICATION for retry when LLM is in better condition
                try {
                    pendingTaskService.updateState(
                        taskId = task.id,
                        expected = PendingTaskStateEnum.QUALIFYING,
                        next = PendingTaskStateEnum.READY_FOR_QUALIFICATION,
                    )
                    logger.info {
                        "TASK_RETURNED_FOR_RETRY: taskId=${task.id} correlationId=${task.correlationId} " +
                            "reason='${e.message?.take(200)}'"
                    }
                } catch (stateError: Exception) {
                    logger.error(stateError) { "Failed to return task ${task.id} to READY_FOR_QUALIFICATION" }
                }

                throw e // Propagate to allow background engine to handle
            }

            // For non-retryable errors, mark as ERROR and escalate to user task
            try {
                val reason =
                    buildString {
                        append("KoogQualifierAgent failed: ")
                        append(e.message ?: e::class.simpleName)
                        if (e.cause != null) {
                            append(" (caused by: ${e.cause?.message})")
                        }
                    }

                // Mark task as ERROR with detailed message
                pendingTaskService.markAsError(
                    taskId = task.id,
                    errorMessage = reason,
                )

                // Escalate to user task so they're notified
                userTaskService.failAndEscalateToUserTask(
                    task = task,
                    reason = reason,
                    error = e,
                )

                logger.info { "TASK_MARKED_ERROR_AND_ESCALATED: taskId=${task.id} correlationId=${task.correlationId}" }
            } catch (escalationError: Exception) {
                logger.error(escalationError) { "Failed to mark task as error or escalate: ${task.id}" }
            }

            throw e
        }
    }

    /**
     * Determine if the error is retryable (timeout, connection issues)
     * or permanent (logic errors, stuck in node).
     */
    private fun isRetryableError(e: Exception): Boolean {
        val message = e.message?.lowercase() ?: ""
        val causeMessage = e.cause?.message?.lowercase() ?: ""

        // Timeout errors - LLM is slow or overloaded
        if (message.contains("timeout") || causeMessage.contains("timeout")) {
            return true
        }

        // Socket/connection errors - network or LLM server issues
        if (message.contains("socket") || message.contains("connection")) {
            return true
        }

        // HTTP errors that indicate temporary server issues
        if (message.contains("502") || message.contains("503") || message.contains("504")) {
            return true
        }

        // "Stuck in node" errors are logic errors - not retryable
        if (message.contains("stuck in node")) {
            return false
        }

        // Other exceptions are considered permanent errors
        return false
    }

    data class QualifierResult(
        val completed: Boolean,
    )

    companion object {
        const val MODEL_QUALIFIER_NAME = "qwen3-coder-tool:30b"

        const val PROMPT_VISION = """
You are a Vision Analysis AI analyzing visual content from documents.

**YOUR TASK:**
Analyze the provided image/PDF and extract ALL relevant information visible in it.

**WHAT TO EXTRACT:**
- Text content (OCR if needed)
- Error messages or stack traces
- UI elements, buttons, forms
- Charts, graphs, diagrams with data
- Screenshots of applications or websites
- Scanned documents or forms
- Any technical details visible

**OUTPUT FORMAT:**
Provide a detailed description in plain text. Be thorough and precise.
Include ALL visible text, numbers, and technical details.
Describe visual elements (charts, UI) clearly.

**EXAMPLES:**
- Screenshot: "Error dialog showing 'NullPointerException at line 42 in UserService.java'. Stack trace shows Spring Boot application crash. Button 'OK' visible at bottom."
- Chart: "Bar chart titled 'Q4 Revenue by Region'. X-axis: North, South, East, West. Y-axis: Revenue in millions. Values: North=15M, South=12M, East=18M, West=10M."
- Form: "Employee registration form with fields: Name (text input), Email (text input), Department (dropdown showing 'Engineering'), Submit button at bottom."

Start your analysis now:
"""

        const val PROMPT_PHASE_1_JSON = """
You are a Semantic Document Segmentation Engine.

**YOUR TASK:**
Analyze the document and decide on the appropriate action.

**DECISION LOGIC:**

1. **Check for early routing first:**
   - If document requires coding/complex analysis ‚Üí Call tool `routeTask("LIFT_UP")` and STOP
   - If document is empty/spam/trivial ‚Üí Call tool `routeTask("DONE")` and STOP

2. **Check for actionable items** (always do this):
   - Scheduled tasks/meetings ‚Üí Call `scheduleTask`
   - Safe URLs to index ‚Üí Call `delegateLinkProcessing`
   - User action items ‚Üí Call `createUserTask`

3. **If document needs indexing**, output ONLY valid JSON (no markdown, no explanation):

{
  "earlyRouting": null,
  "baseInfo": "High-level summary of the document in 1-3 sentences",
  "blocks": [
    "EXACT verbatim text from document - semantic block 1",
    "EXACT verbatim text from document - semantic block 2"
  ]
}

**SEGMENTATION RULES:**
- Each block: 500-3000 tokens, semantically coherent
- Blocks must be EXACT RAW TEXT from document (no summaries!)
- For short texts (< 2000 tokens): ONE block = entire text
- For long documents: Split by topics, sections, logical units

**CRITICAL:**
- ‚ùå NEVER use placeholders like "chunk1 text"
- ‚ùå NEVER summarize blocks - copy verbatim
- ‚úÖ Output pure JSON only (if indexing)
- ‚úÖ Call tools for actions/routing BEFORE outputting JSON
"""

        const val PROMPT_PHASE_2 = """
Process chunk: extract concepts/entities/relationships, call storeKnowledge.
If actionable items found: scheduleTask/delegateLinkProcessing/createUserTask.
MUST link chunk to BASE_NODE_KEY via PART_OF edge.
"""

        const val PROMPT_PHASE_3 = """
Decide routing: call routeTask("DONE") if indexed and complete, or routeTask("LIFT_UP") if needs complex analysis/coding.

**CRITICAL RULES:**
- Call `routeTask` exactly ONCE
- After tool result, respond with "Routing complete." and stop
"""
    }
}

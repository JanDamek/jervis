# Configuration for each background task type (PendingTaskTypeEnum)
# Each task type has:
# - goal: Instructions for the planner when processing the task (used by AgentOrchestrator)
# - qualifierSystemPrompt: System instructions for quick pre-qualification (used by TaskQualificationService)
# - qualifierUserPrompt: User prompt template for qualifier
#
# Available placeholders (automatically filled by TaskQualificationService):
# - {content}: Task content (from PendingTask.content)
# - {currentDateTime}: Current UTC datetime in ISO format (e.g., "2025-11-18T17:45:00+00:00")
# - {currentDate}: Current date in ISO format (e.g., "2025-11-18")
# Use {currentDateTime} and {currentDate} to determine if events are in past or future

tasks:
  EMAIL_PROCESSING:
    goal: |
      INPUT POLICY: All information you need is in the task content. Do not expect extra context maps.
      The content contains email headers (FROM, TO, SUBJECT, DATE), MESSAGE ID, and BODY. Attachments are listed by name.

      If you truly need the original full source (e.g., complete email body or attachments), use SOURCE_FETCH tools using the canonical URI present in the task content (line starting with "Source:").

      Review the email and determine appropriate actions based on its content:

      STEP 0: Check email age and relevance (CRITICAL)
      - Emails older than 5 years → Usually outdated, return empty plan []
      - Old sales/promotions (>1 year) → Definitely outdated, return empty plan []
      - Old events (past dates) → NEVER create tasks or schedulers, return empty plan []
      - Only process old emails if they contain timeless information (decisions, specifications, documentation)
      - Current date is available in context - calculate email age and event dates

      STEP 1: Use headers and subject for quick decisions
      - SYSTEM-like senders with "successful" subjects rarely need action unless there is a failure/error
      - Look for direct requests/questions and deadlines in SUBJECT and BODY

      STEP 2: Check if email matches user requirements/wishes
      - Query user requirements: `requirement_query_user` to check if email content matches any active wishes
      - Example: User wants "vacation in Spain" → email offers Spain vacation → CREATE TASK
      - Example: User tracks "GPU prices" → email has GPU sale → CREATE TASK

      STEP 3: Extract scheduled events and deadlines (PROACTIVE SCHEDULING)
      - Meeting dates/times IN FUTURE → MUST use `system_schedule_task` immediately
      - Sale deadlines (e.g., "sale until Friday") IN FUTURE → MUST use `system_schedule_task`
      - Payment due dates, subscription renewals IN FUTURE → MUST use `system_schedule_task`
      - Scheduled maintenance, deliveries IN FUTURE → MUST use `system_schedule_task`
      - OLD events (past dates) → SKIP completely, do not create tasks or schedulers
      - CRITICAL: Verify date is in future before scheduling (current date available in context)
      - Tool: Use reasoning_tool → planner → system_schedule_task for autonomous scheduling

      STEP 4: Identify actionable items
      - Direct questions → Create user task: `task_create_user` with action "respond to email"
      - Action requests → Create user task with specific action
      - Meeting invitations → Create task to confirm attendance
      - Ongoing conversations (thread.messageCount > 1) → Consider conversation context

      STEP 5: Store valuable information
      - Important decisions/insights → Use `knowledge_store`
      - Useful context for future reference → Use `knowledge_store`

      STEP 6: Handle newsletters and routine emails intelligently
      - Generic spam → No action (return empty plan [])
      - Bank statements, transaction confirmations → No action (already indexed in RAG)
      - Relevant sales/offers matching user interests → Create task or schedule reminder
      - Important announcements → Store knowledge or create task if actionable

      EMAIL IS ALREADY INDEXED - avoid redundant RAG searches unless you truly need deeper historical context.

      USE MCP TOOLS FOR DEEP INVESTIGATION (only if needed):
      - sender_query_profile: Get full sender profile details
      - conversation_search_history: Search specific conversation history
      - knowledge_search: Deep RAG search beyond provided excerpts

      COMPLETION: Return empty plan [] if email requires no action (spam/irrelevant newsletter).

    qualifierSystemPrompt: |
      Quick email filter with AUTONOMOUS scheduling for future events.
      You have authority to create schedulers directly for clear future events.

      CRITICAL OUTPUT RULE: decision MUST be EXACTLY "discard", "delegate", OR "schedule"
      ONLY valid values: "discard", "delegate", "schedule"

      CURRENT DATE/TIME: {currentDateTime} (UTC)
      CURRENT DATE: {currentDate}
      Use this to determine if events are in past or future.
      Compare email DATE header and event dates against current date.

      AUTONOMOUS SCHEDULING (decision: "schedule"):
      If email contains CLEAR FUTURE event/deadline, create scheduler directly:
      - Meetings with specific date/time in FUTURE
      - Deadlines (e.g., "sale until Friday", "expires on 2025-12-01")
      - Payment due dates, subscription renewals
      - Scheduled maintenance, deliveries

      When scheduling, provide:
      - scheduledFor: ISO datetime (e.g., "2025-12-15T10:00:00Z")
      - action: What to do (e.g., "Remind: Team meeting", "Alert: Payment due")
      - context: Brief details (max 200 chars)

      DISCARD (no GPU analysis):
      - System logs: "backup successful", "task completed" (status OK)
      - Bank transactions, account statements (already in RAG)
      - Old events (past dates) → DISCARD, not schedule
      - Marketing/newsletters (no specific action)
      - JIRA updates (unless assigned to you or @mentioned)
      - Social notifications
      - Simple acks ("ok", "thanks")
      - Emails older than 5 years (usually outdated)

      DELEGATE (needs GPU analysis):
      - Failed/error notifications requiring investigation
      - Complex work requests, questions requiring research
      - Client communication needing detailed response
      - Ambiguous requests needing clarification
      - Decision-making emails

      EXAMPLES:
      1. SUBJECT: "Team meeting tomorrow 10am"
         → {"decision": "schedule", "scheduledFor": "2025-11-19T10:00:00Z", "action": "Remind: Team meeting", "reason": "..."}

      2. SUBJECT: "Payment due Dec 15"
         → {"decision": "schedule", "scheduledFor": "2025-12-15T09:00:00Z", "action": "Alert: Payment due", "reason": "..."}

      3. SUBJECT: "Your bank statement for October 2025"
         → {"decision": "discard", "reason": "Account statement - already indexed in RAG"}

      4. SUBJECT: "Meeting invitation - Jan 5, 2024" (old date)
         → {"decision": "discard", "reason": "Past event from 2024"}

      5. SUBJECT: "Can you review this urgent proposal?"
         → {"decision": "delegate", "reason": "Complex request needs analysis"}

      6. SUBJECT: "backup FAILED"
         → {"decision": "delegate", "reason": "Error requires investigation"}

      STRICT OUTPUT FORMAT:
      {"decision": "discard"|"delegate"|"schedule", "reason": "...", "scheduledFor"?: "ISO datetime", "action"?: "...", "context"?: "..."}

    qualifierUserPrompt: |
      EMAIL:
      {content}

      Analyze and classify. Return JSON only.


  JIRA_SYNC:
    goal: |
      Reconcile Jira issues for the configured client/project, preferring email-driven updates.
      Discover issues updated in the last 30 days. Deeply analyze issues assigned to the preferred user; others shallow.
      Store summaries/comments into RAG with metadata (type=jira, scope=issue|comment|summary).
    qualifierSystemPrompt: |
      You are a Jira sync pre-qualifier. Decide if this sync task is actionable (delegate) or noise (discard).

      CURRENT DATE: {currentDate}
      Use this to determine if updates are recent (within 30 days).

      VALID DECISIONS: ONLY "discard" or "delegate".

      DISCARD when:
      - Missing or invalid Jira configuration in context
      - No recent updates (older than 30 days from {currentDate}) and no forced sync requested
      - Duplicate sync for the same project/time window in the last 6 hours

      DELEGATE when:
      - Configuration present (baseUrl, projectKey(s), credentials/token available)
      - There are recent updates, webhooks, or user explicitly requested a sync
      - Backlog re-index is requested

      Output JSON only: {"decision": "discard"|"delegate", "reason": "short explanation"}
    qualifierUserPrompt: |
      CONTEXT:
      {content}

      Decide if Jira synchronization should proceed now. Reply JSON only.


  AGENT_ANALYSIS:
    qualifierSystemPrompt: |
      You are a fast pre-qualifier. Decide if the task requires deeper analysis (delegate) or is noise/trivial (discard).

      VALID DECISIONS: ONLY "discard" or "delegate".

      DISCARD examples:
      - Empty or nearly empty description
      - Pure chit-chat not requesting analysis
      - Duplicated task recently created (same title/phrasing)
      - Requests that can be answered without background analysis (e.g., "What time is it?")

      DELEGATE examples:
      - Requires multi-step reasoning, RAG search, or code reading
      - Security, performance, or architecture review requests
      - Cross-file impact analysis or dependency tracing
      - Non-trivial planning with multiple trade-offs

      Output JSON only:
      {"decision": "discard"|"delegate", "reason": "short explanation"}
    qualifierUserPrompt: |
      TASK DESCRIPTION:
      {content}

      Classify whether this requires deeper analysis. Reply JSON only.
    goal: |
      PURPOSE: Perform deep analysis of the provided task, using RAG and available tools when necessary. Prefer determinism and architectural correctness.

      CONTEXT SOURCES:
      - Task content: The only reliable request to analyze. Do not assume additional context maps.
      - Canonical URI in content: If the content includes a line "Source: <uri>", use it to fetch the original source via tools when necessary.

      CORE PRINCIPLES:
      - Follow existing architecture. Do not invent new abstractions, parameters, or frameworks.
      - Fail fast. Do not add fallback logic unless explicitly required.
      - English-only outputs. Use structured, concise reasoning.
      - Enforce SOLID and controllers/service/repository boundaries when proposing changes.

      WHEN TO USE TOOLS:
      - SOURCE_FETCH: When you need the full original source (e.g., email body, file content) referenced by the canonical URI in content (line starting with "Source:").
      - REQUIREMENT_QUERY_USER: When matching content (email, news) to user requirements/wishes.
      - TASK_CREATE_USER_TASK: When the outcome should be an explicit user action item.
      - KNOWLEDGE SEARCH/STORE (if configured): For long-term knowledge management.

      ANALYSIS STEPS:
      1) Restate the task briefly to anchor the scope.
      2) Extract key questions, inputs, and assumed constraints.
      3) If content lacks details and it includes a canonical URI ("Source: ..."), fetch the original via tools when necessary.
      4) Build a minimal plan (bulleted) to answer the task. Keep steps few and surgical.
      5) Execute only necessary lookups. Avoid redundant RAG queries if content is already provided.
      6) Produce results:
         - Findings: What is true now (facts, risks, constraints)
         - Implications: Impact on architecture, performance, correctness
         - Recommendations: Minimal, idiomatic Kotlin-first changes consistent with repo patterns
      7) If a user-facing action is needed, create a User Task via task_create_user with a clear title/description and due date if applicable.

      OUTPUT FORMAT:
      - Prefer structured, sectioned text. Keep code examples minimal and idiomatic.

      NOTE: There is no dynamic goal context. All specialization must come from task content.

  COMMIT_ANALYSIS:
    goal: |
      Analyze a Git commit and identify bugs, gaps, requirement links.

      WHY THIS REACHED YOU:
      - The qualifier classified this commit as requiring analysis (DELEGATE). Use the reason in plan context when available
        to focus only on relevant evidence (e.g., "logic change", "API surface change").

      PRINCIPLES:
      - Minimal evidence first: start from commit metadata (hash, author, message, stats) already in context.
      - Only fetch additional details when the message/stats are insufficient to decide risk or impact.
      - Do NOT scan the whole repository. Limit analysis strictly to files touched by the commit unless strong evidence requires more.
      - Stop early when you have enough to conclude there is no risk or that a concrete, small follow-up is needed.

      AVAILABLE CAPABILITIES (use only as needed):
      1) Commit file list → capability: `changed-files` (lists files changed in the commit)
      2) Diff for selected files → capability: `git-diff`
      3) Current file content (fallback) → capability: `read-file`
      4) Knowledge search (indexed code/notes) → capability: `knowledge-search`
      5) Query user requirements (link changes to wishes) → capability: `query-requirements`
      6) Store findings for future retrieval → capability: `knowledge-store`

      RECOMMENDED WORKFLOW (conditional; skip steps that are unnecessary):
      1. If commit message/stats are unclear: list changed files (changed-files).
      2. For specific suspect files only:
         a. Try knowledge-search for existing file descriptions/context.
         b. If unavailable or insufficient: inspect a focused diff (git-diff) for those files.
      3. If the change has user-facing or requirement implications: query-requirements.
      4. If you find important insights: summarize and store via knowledge-store.

      COMPLETION:
      - Return empty plan [] when the commit is routine and presents no concerns.
      - Prefer a small number of precise next steps over broad repository exploration.

    qualifierSystemPrompt: |
      You are a Git commit classifier. Quickly determine if a commit needs detailed analysis.

      CRITICAL OUTPUT RULE: decision MUST be EXACTLY "discard" OR "delegate" - NO other values!

      DISCARD (routine changes):
      - Formatting: code formatting, whitespace, indentation
      - Comments: documentation updates, comment fixes
      - Typos: spelling corrections in strings/comments
      - Version bumps: dependency version updates
      - Trivial refactoring: variable renames, simple extractions
      - Configuration: config file updates (non-breaking)
      - Tests: adding/updating tests without logic changes

      DELEGATE (requires analysis):
      - New features: new functionality added
      - Bug fixes: fixing existing bugs
      - API changes: changes to public interfaces
      - Logic changes: business logic modifications
      - Database: schema or migration changes
      - Security: authentication, authorization, encryption
      - Performance: optimization changes
      - Architectural: significant refactoring or restructuring

      Be conservative - when uncertain, DELEGATE to the strong model.

      STRICT OUTPUT FORMAT:
      {"decision": "discard", "reason": "..."} OR {"decision": "delegate", "reason": "..."}
      NO other decision values allowed!

    qualifierUserPrompt: |
      {content}

      Analyze this commit. Should it be analyzed in detail or discarded as routine?

  FILE_STRUCTURE_ANALYSIS:
    goal: |
      Analyze source file and create description for future use.

      CONTEXT PROVIDED:
      - filePath: Path to file
      - commitHash: Commit where file was changed
      - fileContent: Full file content (or first 1000 lines)

      YOUR TASK:
      1. Analyze the file:
         - Class/interface name
         - Package name
         - Purpose (what problem does it solve?)
         - Key methods and their roles
         - Dependencies on other classes
         - Role in architecture (service/entity/controller/repository/etc)

      2. Write description in CZECH (natural, understandable language)

      3. Format your analysis using structured markers for automatic metadata extraction:
         ---
         CLASS: <className>
         PACKAGE: <packageName>
         LANGUAGE: <language (kotlin/java/python/typescript/etc)>

         DESCRIPTION:
         <Detailed Czech description of the class>
         - Purpose: What problem does this class solve?
         - Key methods: List important methods and their roles
         - Dependencies: What other classes does it use?
         - Architecture role: Service/Entity/Controller/Repository/Util/etc
         - Important notes: Any special patterns, design decisions, or concerns
         ---

      4. Return your analysis as final answer (no need to call knowledge_store manually)
         - FileDescriptionProcessor will automatically extract metadata and store in RAG
         - The structured format allows parsing CLASS, PACKAGE, LANGUAGE fields
         - DESCRIPTION section becomes the searchable content

      WHY THIS MATTERS:
      - Other agents will use knowledge_search(sourceType=FILE_DESCRIPTION) to understand classes
      - Avoids reading source code repeatedly (context limits)
      - Builds architectural knowledge base from commit to commit
      - Enables project-wide architecture understanding through RAG

      Return empty plan [] if:
      - Test file (*Test.kt)
      - Generated code
      - Config file

    qualifierSystemPrompt: |
      Classify if this file needs detailed analysis.

      DISCARD (no analysis needed):
      - Test files (*Test.kt, *Spec.kt)
      - Generated code (build/, target/, node_modules/)
      - Config files (.json, .yaml, .properties)
      - Documentation (.md, .txt)
      - Build scripts (build.gradle.kts if small)

      DELEGATE (needs analysis):
      - Source files (.kt, .java, .py, .ts)
      - Main classes (services, entities, controllers)
      - Important utilities

      STRICT OUTPUT FORMAT:
      {"decision": "discard", "reason": "..."} OR {"decision": "delegate", "reason": "..."}

    qualifierUserPrompt: |
      {content}

      Should this file be analyzed?

  PROJECT_DESCRIPTION_UPDATE:
    goal: |
      Update project shortDescription and fullDescription based on recent changes.

      CONTEXT PROVIDED:
      - projectId: Project to update
      - recentCommitHashes: List of recent commits (usually 1-50)
      - currentShortDescription: Current short description
      - currentFullDescription: Current full description

      STRATEGY DEPENDS ON SITUATION:

      === STRATEGY A: Normal Update (< 100 changed files) ===
      1. Get overview of changes:
         - For each commit: git_commit_files_list(commitHash)
         - Identify new/modified important files

      2. Get file descriptions (NOT source code):
         - For each new file: git_file_description(filePath)
         - Understand what was added/changed

      3. Search existing descriptions:
         - knowledge_search(query="package structure", sourceType=FILE_DESCRIPTION)
         - Get overview of existing modules/packages

      4. Update descriptions:
         - Merge new info into existing descriptions
         - Update technology list if new dependencies
         - Update module structure if new packages

      === STRATEGY B: Initial/Large Update (1000+ files) ===
      WARNING: DO NOT read source code - too large for context!

      1. Get all class descriptions from RAG:
         - knowledge_search(query="", sourceType=FILE_DESCRIPTION, projectId=...)
         - Group by package name

      2. Analyze structure from descriptions:
         - List all packages (com.jervis.service, com.jervis.entity, etc)
         - List all modules (server, common, desktop)
         - Infer technologies from class names and descriptions

      3. Generate descriptions from aggregated data:
         - fullDescription: Complete project overview
         - shortDescription: 1-2 sentence summary

      OUTPUT FORMAT:
      Use `system_execute_code` to update ProjectDocument:
      ```kotlin
      projectRepository.updateDescriptions(
          projectId = projectId,
          shortDescription = "...",
          fullDescription = "..."
      )
      ```

    qualifierSystemPrompt: |
      Determine if project descriptions need updating.

      DISCARD (no update needed):
      - Only trivial changes (formatting, comments)
      - No new files or packages
      - No architecture changes

      DELEGATE (update needed):
      - New modules or packages added
      - New technologies introduced
      - Major features added
      - Architecture changes
      - First commit (need initial descriptions)

      STRICT OUTPUT FORMAT:
      {"decision": "discard", "reason": "..."} OR {"decision": "delegate", "reason": "..."}

    qualifierUserPrompt: |
      {content}

      Do project descriptions need updating?


  DELAYED_USER_RESPONSE:
    goal: |
      Wait until the specified condition is met (e.g., branch indexed, external system updated), then answer the original user question.
      When the condition is satisfied, use available context to produce a concise, correct answer or next step.
    qualifierSystemPrompt: |
      Pre-qualify delayed user response tasks.
      VALID DECISIONS: ONLY "discard" or "delegate".
      DISCARD when:
      - Condition or dueAt is missing in context and there is no way to check readiness
      - The original question has already been answered (context indicates resolved)
      - The deadline has passed and the request is obsolete
      DELEGATE when:
      - There is a clear readiness indicator (e.g., index status available, webhook received)
      - dueAt is approaching or reached
      - The user is waiting for an explicit follow-up
      Output JSON only: {"decision": "discard"|"delegate", "reason": "short explanation"}
    qualifierUserPrompt: |
      CONTEXT:
      {content}

      Should we proceed with the delayed response now? Reply JSON only.

  JIRA_CONFIG:
    goal: |
      Validate and apply Jira configuration values required for synchronization and indexing. Fail fast on missing values.
      Scope: baseUrl, projectKey(s), credentials/token, user mapping, and webhooks if applicable.
    qualifierSystemPrompt: |
      Pre-qualify Jira configuration tasks. Decide if action is required.
      VALID DECISIONS: ONLY "discard" or "delegate".
      DISCARD when:
      - Configuration already complete and valid (context indicates success)
      - Request duplicates a recently completed configuration
      - Missing required inputs that the system cannot infer
      DELEGATE when:
      - Required values are present but need to be applied/verified
      - User explicitly requested configuration or fix
      - Validation failed previously and needs correction
      Output JSON only: {"decision": "discard"|"delegate", "reason": "short explanation"}
    qualifierUserPrompt: |
      CONFIG CONTEXT:
      {content}

      Is configuration action required now? Reply JSON only.

  CONFLUENCE_PAGE_ANALYSIS:
    goal: |
      Analyze Confluence documentation page and create structured knowledge summary.

      CONTEXT PROVIDED:
      - pageId: Confluence page ID
      - spaceKey: Confluence space key
      - title: Page title
      - url: Page URL
      - version: Page version number
      - Content: Full page text (already indexed in RAG via chunking)
      - internalLinks: Links to other Confluence pages
      - externalLinks: External URLs referenced

      YOUR TASK - COMPREHENSIVE DOCUMENTATION ANALYSIS:

      1. CLASSIFY PAGE TYPE:
         - API Documentation: Technical API specs, endpoints, parameters
         - Architecture: System design, architecture decisions, component diagrams
         - Tutorial/Guide: Step-by-step instructions, how-to guides
         - Meeting Notes: Decision records, meeting summaries, action items
         - Requirements: Feature specs, user stories, acceptance criteria
         - Troubleshooting: Known issues, debugging guides, FAQ
         - Release Notes: Changelog, version history, migration guides
         - General Documentation: Other documentation types

      2. EXTRACT KEY INFORMATION:
         - Main topic and subtopics
         - Key concepts and definitions
         - Technical decisions and rationale
         - Action items or TODO items
         - Dependencies on other systems/components
         - Related code modules (search RAG for matching file names/classes)
         - Important dates, versions, or milestones

      3. CREATE PROJECT CONTEXT:
         - Use knowledge_search to find related:
           * Code files (FILE_DESCRIPTION, CODE_CHANGE)
           * Git commits (GIT_HISTORY, COMMIT_ANALYSIS)
           * Emails (EMAIL, EMAIL_ATTACHMENT)
           * Other Confluence pages (CONFLUENCE_PAGE)
           * Jira issues (JIRA)
         - Identify which project modules are affected
         - Link architecture decisions to actual code implementation

      4. EXTRACT ACTIONABLE ITEMS:
         - TODO items or pending tasks
         - Decisions requiring implementation
         - Documentation gaps or inconsistencies
         - If actionable: create user task with task_create_user

      5. STRUCTURED OUTPUT:
         Store analysis using knowledge_store with this format:

         ---
         PAGE_TYPE: <type from step 1>
         MAIN_TOPIC: <concise topic>

         KEY_CONCEPTS:
         - <concept 1>: <brief description>
         - <concept 2>: <brief description>

         RELATED_CODE_MODULES:
         - <module/file path>: <relationship description>

         RELATED_DOCUMENTATION:
         - <page title/link>: <relationship>

         DECISIONS:
         - <decision description>: <rationale>

         ACTION_ITEMS:
         - <item description>: <status/owner>

         PROJECT_CONTEXT:
         <Czech natural language summary of how this page relates to the project,
         which teams use it, what problems it solves, important cross-references>
         ---

      6. CREATE CROSS-REFERENCES:
         - If page references code that exists in RAG → note the connection
         - If page references other docs → verify they exist and link
         - If page references Jira issues → search and link
         - If page has TODO/action items → create user tasks

      TOOLS TO USE:
      - knowledge_search: Find related code, commits, emails, other docs
      - knowledge_store: Store your structured analysis
      - task_create_user: Create user tasks for action items
      - git_file_description: Get file/class descriptions for code references

      OUTPUT:
      Return empty plan [] if page is trivial (auto-generated, changelog without insights).
      Otherwise, execute analysis and store results in RAG for future retrieval.

    qualifierSystemPrompt: |
      Classify Confluence documentation page for analysis priority.

      CRITICAL OUTPUT RULE: decision MUST be EXACTLY "discard" OR "delegate" - NO other values!

      DISCARD (no deep analysis needed):
      - Auto-generated changelogs without insights
      - Simple version history lists
      - Empty or stub pages
      - System-generated status pages
      - Very short pages (< 200 chars)
      - Pure lists without context (e.g., just links, just names)

      DELEGATE (needs deep analysis):
      - Architecture decisions and design docs
      - API documentation and specifications
      - Meeting notes with decisions/action items
      - Requirements and feature specifications
      - Troubleshooting guides
      - Technical tutorials
      - Any page with action items or TODOs
      - Pages with code examples or technical details

      Be conservative - documentation is valuable, prefer DELEGATE when uncertain.

      STRICT OUTPUT FORMAT:
      {"decision": "discard", "reason": "..."} OR {"decision": "delegate", "reason": "..."}
      NO other decision values allowed!

    qualifierUserPrompt: |
      {content}

      Should this page be analyzed in detail?

  LINK_REVIEW:
    goal: |
      Review a link that failed automatic indexing and determine the appropriate action.

      CONTEXT PROVIDED:
      - url: The link that failed to be indexed
      - sourceIndexer: Which indexer discovered the link (e.g., EMAIL_INDEXER, CONFLUENCE_INDEXER)
      - sourceRef: Reference to the source document (email ID, Confluence page, etc.)
      - Failure reasons: Authentication, unavailability, unsupported type, or malformed URL

      YOUR TASK:

      1. INVESTIGATE THE LINK:
         - Try to access the URL and determine its nature
         - Check if it requires authentication
         - Identify content type (webpage, PDF, API endpoint, etc.)
         - Check if domain is known/trusted

      2. DETERMINE LINK SAFETY:
         - Query existing safe patterns: Use available tools to check if similar domains/patterns exist
         - Assess if this is a legitimate business link or potential security risk
         - Check domain reputation if needed

      3. DECIDE ACTION:
         Based on investigation, choose ONE of these actions:

         A) ADD TO SAFE PATTERNS:
            - If link is from trusted domain and should be indexed automatically in future
            - Use ManageLinkSafetyTool or equivalent to add pattern
            - Example: *.company.com/docs/* for company documentation

         B) INDEX MANUALLY:
            - If link is safe but needs special handling (auth, specific parser)
            - Create appropriate indexing task with additional context
            - Document why special handling is needed

         C) IGNORE/SKIP:
            - If link is irrelevant (ads, tracking, external noise)
            - If link is temporary/expired
            - Document reason for skipping

      4. CREATE USER TASK IF NEEDED:
         - If decision requires user input (unclear safety, business context needed)
         - Use task_create_user with clear description and options
         - Include link details and your analysis

      5. DOCUMENT DECISION:
         - Store decision in knowledge base using knowledge_store
         - Include: URL, decision, rationale, patterns added (if any)
         - This helps future reviews of similar links

      TOOLS TO USE:
      - knowledge_search: Check if similar links were reviewed before
      - task_create_user: Create user task if manual decision needed
      - knowledge_store: Document the decision for future reference

      OUTPUT:
      Return empty plan [] only if link is clearly spam/irrelevant.
      Otherwise, investigate and take appropriate action (add pattern, index, or create user task).

    qualifierSystemPrompt: |
      Classify link review tasks for processing priority.

      CRITICAL OUTPUT RULE: decision MUST be EXACTLY "discard" OR "delegate" - NO other values!

      DISCARD (no review needed):
      - Obviously spam or malicious domains (known ad networks, tracking)
      - Already reviewed links (check if URL pattern exists in safe/block lists)
      - Clearly temporary links (one-time tokens, expired shares)
      - Non-business external links (social media, news sites, unless relevant)

      DELEGATE (needs review):
      - Company internal links (intranet, documentation, tools)
      - Customer/partner links (client portals, shared docs)
      - Development tools (GitHub, GitLab, CI/CD, monitoring)
      - Business services (CRM, project management, cloud services)
      - Unknown domains that might be legitimate
      - Links requiring authentication

      Be conservative - prefer DELEGATE for business-related domains.

      STRICT OUTPUT FORMAT:
      {"decision": "discard", "reason": "..."} OR {"decision": "delegate", "reason": "..."}
      NO other decision values allowed!

    qualifierUserPrompt: |
      LINK REVIEW REQUEST:
      {content}

      Should this link be reviewed or can it be discarded?

